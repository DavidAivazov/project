# მუდმივა - ხელი არ შეეხოთ, ამას გამოიყნებთ main ფუნქციაში
RIGI = [5, 2, 1, 3, 4, 1, 4]
import time


"""
0. დაწერეთ ფუნქცია, რომელიც სიის მონაცემთა ტიპის ჩაშენებული ფუნქციის
გამოძახებით, elementi არგუმენტად მიწოდებულ მონაცემის პირველ ინდექსს
(ადგილმდებარეობას) იპოვის არგუმენტად მიწოდებულ sia სიაში.

მაგალითად, თუ გვექნება სია, [1,2,3,1,4,4]
და ვეძებთ ელემენტის, 1-ის, პირველ შემთხვევას, ჩვენ შედეგად მივიღებთ
ინდექს 0-ს, იმისდამიუხედავად, რომ 1-იანი მე-0 და მე-3 ადგილზე გვხვდება.
ანალოგიურად, თუ ვეძებთ ელემენტ 4-ს, ჩვენ დაგვიბრუნდება 4 და არა 5, იგივე
მიზეზის გამო.

(ეს ჩემი რეკომენდაციაა, თუმცა, უფრო რთულად, შეგიძლიათ აწარმოოთ ციკლი

:param sia: list სია; რაშიც ვეძებთ ელემენტს
:param elementi: any რამე მონაცემთა ტიპი; რის ინდექსაც (ადგილმდებარეობას)
ვეძებთ
:return: int მთელრიცხვა მონაცემთა ტიპი; წარმოადგენს ელემენტის მარცხნიდან
მოყოლებულ პირველ ადგილმდებარეობას (ინდექსს)
"""
def sia_index(sia,element):
    print(f"ჩვენ გვაქვს ასეთი სია: {sia}")
    print(f"თქვენ გსურთ {element}-ის ინდექსის გაგება.")
    if ((element in sia) is True):
        index = sia.index(element)
        print(f"{element}-ელემენტს {sia}-სიაში აქვს ინდექსი: {index}")
        return index
    else:
        print(f"{element} ელემენტი სიაში არ მოიძებნება!")
#ტესტირება
#sia_index([5,2,3,5,6],6)



"""
1. დაწერეთ ფუნქცია, რომელიც არგუმენტად მიწოდებულ სიაში, მეორე
არგუმენტად მიწოდებულ ელემენტების რაოდენობას დაითვლის:

0. სიის მონაცემთა ტიპის ჩაშენებული ფუნქციის გამოძახებით დაითვალე
elementi-ს რაოდენობა sia-ში
(ეს ჩემი რეკომენდაციაა, თუმცა, უფრო რთულად, შეგიძლიათ რომ აწარმოოთ
ციკლი რომ იგივე შედეგამდე მიხვიდეთ; ამას არ გირჩევთ)

:param sia: list სია; რაშიც ვეზებთ და ვითვლით ელემენტების რაოდენობას
:param elementi: any რამე მონაცემთა ტიპი; რასაც ვეძებთ და ვითვლით
:return: int მთელრიცხვა ტიპი
"""
def sia_count(sia,element):
    print(f"ჩვენ გვაქვს ასეთი სია: {sia}")
    print(f"თქვენ გსურთ {element}-ის სიაში რაოდენობის გაგება.")
    if ((element in sia) is True):
        count = sia.count(element)
        print(f"ელემენტი {element} სიაში:{sia} {count}-ჯერ არის მოთავსებული")
        return count
    else:
        print(f"{element} ელემენტი სიაში არ მოიძებნება!")
        return 0
#ტესტირება
#sia_count([5,2,3,5,6],5)

"""
2. სიის მონაცემთა ტიპის ჩაშენებული ფუნქციის გამოძახებით, sia არგუმენტად
მიწდოებული სია დაახარისხეთ

(გაიხსენეთ, ინგლისურად როგორ არის სიტყვა "დახარისხება")
(არაფერი არ დააბრუნოთ, საკმარისია ამ ფუნქციის გამოძახება, რაც შედეგად
მონაცემს სამუდამოდ შეცვლის; დაახარისებს)

მაგალითად, თუ ამ ფუნქციის არგუმენტი იქნება [4,2,2,3,0],
ეს ფუნქცია დააბრუნებს [0,2,2,3,4]

:param sia: list სია; სია, რომელსაც ვახარისხებთ
"""
def sia_sort(sia):
    print(f"ჩვენ გვაქვს ასეთი სია: {sia}")
    print(f"თქვენ გსურთ ამ სიის სორტირება.")
    sia.sort()
    print(f"სორტირების შედეგად ჩვენ მივიღეთ ასეთი სია: {sia}")
    return sia
#ტესტირება
#sia_sort([1,7,5,2,798,23,5,4,0])


"""
3. დაწერეთ ფუნქცია, რომელიც სიმრავლეებისა და სიის კონსრუქტორების გამოძახებით
sia არგუმენტში მიწოდებულ სიას ყველა დუპლიკატებს მოაშორებს და ახალ სიას
დააბრუნებს, რომელშიც არც ერთი მონაცემი განმეორებით არ გხვდება:

0. გამოიძახე სიმრავლის კონსტრუქტორი ფუნქცია; შეინახე ცვლადში
1. წინა ნაბიჯიდან გამოყვანილ ცვლადზე გამოიძახე სიის კონსტრუქტორი
2. დააბრუნე შედეგად მიღებული სია

მაგალითად, თუ ამ ფუნქციის არგუმენტი იქნება [4,2,2,3,0],
ეს ფუნქცია დააბრუნებს [4,2,3,0]

:param sia: list სია; სია, რომელსაც დუპლიკატებს ვაშორებთ
:return: list სია; სია, რომლის არც ერთი მონაცემი განმეორებით არ გვხვდება
"""
def sia_dublicate(sia):
    print(f"ჩვენ გვაქვს ასეთი სია: {sia}")
    print(f"თქვენ გსურთ ამ სიდან დუბლიკატების წაშლა.")
    #სორტირებით
    print(f"სორტირებით:{list(set(sia))}")
    #სორტირების გარეშე
    sia_new = []
    for i in sia:
        if i not in sia_new:
            sia_new.append(i)
    print(f"სორტირების გარეშე: {sia_new}")
    return sia_new,


#ტესტირება
#sia_dublicate([5,5,5,2,2,3,3,3,3,5,6])


"""
4. დაწერეთ ფუნქცია, რომელიც თქვენს ზემოთ შექმნილი ფუნქციების გამოძახებით
შეასრულებს სიის დამუშავებას:
- გამოიძახე მე-2 დაწერილი ფუნქცია, რომელიც სიას ახარისხებს; არგუმენტად
მიაწდოე sia სია
- შემდგომ, გამოიძახეთ მე-3 დაწერილი ფუნქცია, რომელიც სიას დუპლიკატებს
აშორებს; არგუმენტად მიაწოდე sia სია

მაგალითად, თუ ამ ფუნქციის არგუმენტი იქნება [4,2,2,3,0],
ეს ფუნქცია დააბრუნებს [0,2,3,4]

:param sia: list სია; სია, რომელსაც დამუშავება სჭირდება
:return: list სია; დამუშავებული სია
"""
def sia_action(sia):
    print(f"მოცემული სია {sia} უნდა დავამუშავოთ!")
    print(f"ნაბიჯი 1: სიის ახარისხება ")
    time.sleep(1)
    print(f"ნაბიჯი 1: სიის ახარისხების შედეგი {sia_sort(sia)}")
    print(f"ნაბიჯი 2: დუბლიაკტების მოშორება ")
    time.sleep(1)

    print(f"ნაბიჯი 2: დუბლიკეტების მოშორების შედეგი {sia_dublicate(sia)}")
    print(f"იმპროვიზაციის ვარიანტი, რომელიც ამ ყველაფერს ერთ სტრიქონში ასრულებს")
    print(f"იმპროვიზაცია: შედეგი {list(set(sia))}")
    return sia
#ტესტირება
#sia_action([5,5,5,2,2,3,3,3,3,5,6])





"""
5. დაწერეთ ფუნქცია, რომელიც პირველ არგუმენტად მიწდოებნული სიიდან, მეორე
არგუმენტად მიწოდებულ ინდექსზე მყოფ მონაცემს შლის:

0. ამისი რამოდენიმე გზა არსებობს:
   - გამოიყენეთ "წაშლის" რეზერვირებული სიტყვა და მიაწოდეთ არგუმენტ sia-ში
   არგუმენტ index-ის ინდექსზე მყოფი მონაცემი (ინდექსაცია მოახდინეთ)

   **ან**

   - გამოიძახეთ სიმრავლის მონაცემთა ტიპზე გამართული ერთ-ერთი ფუნქცია


:param sia: list სია; სია, რომლიდანაც ვშლით ინდექსზე მყოფ მონაცემს
:param index: int მთელრიცხვა მონაცემთა ტიპი: ინდექსი, რომელიც აუცილებლად
სიაში არის, და რომელზეც იმყოფება წასაშლელი მონაცემი
"""
def sia_terminate(sia,index):
    print(f"ჩვენ გვაქვს სია {sia} და ინდექსი *{index}*, რომელიც ჩვენ უნდა წავშალოთ.")
    sia.pop(index)
    print(f"შედეგი: {sia}")


"""
6. დაწერეთ ფუნქცია, რომელიც პირველ არუგმენტად მიწოდებულ სიაში იპოვის
მეორე არგუმენტად მიწოდებულ ელემენტს, და მისი არსებობის შემთხვევაში,
მას სიიდან ამოშლის:

0. გამოიძახე ზემოთ, თქვენ მიერ გაწერილი, მე-0 ფუნქცია; არგუმენტებად 
მიაწოდე ამ ფუნქციასი მიღეუბლი sia, elementi არგუმენტები:
    ა. შედეგად მიღებული მონაცემი შეინახე ცვლადში

1. გამოიძახე ზემოთ, თქვენ მიერ გაწერილი მე-5 ფუნქცია; არგუმენტებად მიაწოდე
ამ ფუნქციაში მიღებული არგუმენტი sia და წინა, მე-0 ნაბიჯის შედეგად მიღებული
ცვლადი

:param sia: list სია; რაშიც ვეძებთ ელემენტს
:param elementi: any რამე მონაცემთა ტიპი; რის ინდექსაც (ადგილმდებარეობას)
ვეძებთ, წასაშლელად
"""
def sia_action2(sia,element):
    print(f"ჩვენ გვაქვს სია {sia} და ელემენტი {element}, რომელიც ჩვენ უნდა ვიპოვოთ და ამოვშალოთ")
    index = sia_index(sia,element)
    sia_terminate(sia,index)
    # არ არის საჭირო, ნახეთ 245 სტრიქონი
    #return sia
#ტესტირება
#sia_action2([1,4,6,2,3],2)
def main():
    """
    მთავარი ფუნქცია, სადაც უნდა მოათავსოთ ზემოთ გაწერილი დამხმარე ფუნქციების
    გამოძახება. დეტალურად წაიკითხეთ ფუნქციის ტანში, კომენტარების სახით
    მოცემული ინსტრუქციები.

    ბოლოს მოსალოდნელი შედეგი:
    1: 2
    2: 1
    3: 1
    4: 2
    5: 1
    0
    [5, 2, 1, 3, 4, 1, 4]
    გამზადებული სია: [1, 2, 3, 4, 5]
    წაშლის შედეგად სია: [1,2,4,5]
    """
    # 0. ცვლადს მიანიჭეთ ამ ფაილში არსებული მუდმივას, RIGI-ს, მნიშვნელობა
    rigi = RIGI

    # 1. 1-დან დაწყებული, 6-დე, აწარმოეთ ციკლი:
    # ა. ციკლის თითო იტერაციაზე გამოითვალეთ i ცვლადის რაოდენობა
    # მე-0 ნაბიჯის შედეგად მიღებულ ცვლადში, მე-1 ფუნქციის გამოძახებით
    for i in range(1,6):
        print(f"{i}: {sia_count(rigi,i)}")

    # 2. იპოვე მთელრიცხვა ელემენტის, 5-ის, ინდექსი, მე-0 ნაბიჯში
    # წარმოებულ სიაში, მე-0 ფუნქციის გამოძახების მეშვეობით
    sia_index(rigi,5)

    # 3. შექმენით მე-0 ნაბიჯში შექმნილი სიის ასლი:
    # ა. შეინახეთ ახალ ცვლადში
    # ბ. დაბეჭდეთ ის კონსოლში
    rigi_asli = rigi.copy()
    print(f"მე-0 ნაბიჯში შექმნილი სიის ასლი: {rigi_asli}")

    # 4. მე-4 ფუნქციას არგუმენტად მიაწდოეთ მე-0 ნაბიჯში შექმნილი სია
    # კონსოლში დაბეჭდეთ (გამოიტანეთ) შედეგად მიღებული, დამუშავებული სია
    action_answer = sia_action(rigi)
    # 5. მე-6 ფუნქციას არგუმენტად მიაწოდეთ წინა, მე-4 ნაბიჯის შედეგად მიღებული
    # სია, რომელშიც აღარ არის დუპლიკატები, და მთელრიცხვა მონაცემთა ტიპი 3:
    #      - ამის შედეგად, სიაში არსებული მონაცემი 3 წაიშლება სიიდან
    action2_answer = sia_action2(action_answer,3)
    # 6. მე-6 ნაბიჯის შედეგად მიღებული სია დაბეჭდეთ კონსოლში
    #ზედმეტია, რადგან ფუნქციაში უკვე ისედავ იწერება კონსოლში შედეგი
    #print (action2_answer)

main()
