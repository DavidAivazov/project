import time
# მუდმივები, რომლებსაც ხელი არ უნდა ახლოთ
ELEMENTEBI_1 = [
    3, 4, 5, 2, 3, 1, 2, 4, 'სშია', 'არ სშია'
]


ELEMENTEBI_2 = [
    3, 2, 2, 3, 5, 'სშია', 'სშია', 'სშია'
]
# Elementebi_2 -ში 5-ის გამო, რომელიც  იყო 6, დავხარჯე 30 წუთი +- ;დ, პასუხი არ ემთხვეოდა და მერე
# ვნახე, რომ ქვევითაც შეგეშალათ 6-ის მაგივრად 5 გეწერათ და  რო შევცვალე, ამუშავდა ;ც

"""
0. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებულ სიას გარდაქმნის სიმრავლედ
და დააბრუნებს მას

    :param sia: list სია
    :return: set სიმრავლე 
"""
def list_to_set(sia):
    print(f"ჩვენ გვაქვს სია {sia}, რომელიც სიმრავლედ უნდა გადავაკეთოთ")
    set_result = set(sia)
    print(f"გარდაქმნის შედეგი: {set_result}")
    return set_result
#test
#list_to_set(ELEMENTEBI_1)

"""
1. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებული სიმრავლეების უნისონს
გამოითვლის და დააბრუნებს
    
    :param simravle_a: set სიმრავლე
    :param simravle_b: set სიმრავლე   
    :return: set სიმრავლე, უნისონის ოპერაციის შედეგად მიღებული
"""
def union(simravle_a,simravle_b):
    print(f"ჩვენ გვაქვს ორი სიმრავლე, რომელიც ჩვენ უნდა გავაერთიანოთ!")
    set_union = simravle_a.union(simravle_b)
    print(f"გაერთიანების შედეგი: {set_union}")
    return set_union
#test
union(ELEMENTEBI_1,ELEMENTEBI_2)



"""
2. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებული სიმრავლეების თანაკვეთას
გამოითვლის და დააბრუნებს

    :param simravle_a: set სიმრავლე
    :param simravle_b: set სიმრავლე   
    :return: set სიმრავლე, თანაკვეთის ოპერაციის შედეგად მიღებული
"""
def intersection(simravle_a,simravle_b):
    print(f"ჩვენ გვაქვს ორი სიმრავლე, რომელთა თანაკვეთა უნდა ვიპოვოთ!")
    set_intersection = simravle_a.intersection(simravle_b)
    if set_intersection == set():
        print("მოცემულ სიმრავლეებს არ აქვთ საერთო ელემენტები!")
    else:
        print(f"თანაკვეთა: {set_intersection}")
        return set_intersection
#test
#intersection({1,2},{3,4}), intersection(ELEMENTEBI_1,ELEMENTEBI_2)

"""
3. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებული A და B სიმრავლის
სხვაობას გამოითვლის და დააბრუნებს

    :param simravle_a: set სიმრავლე, სხვაბოის ოპერატორის ხელმარცხენა
    ოპერანდა - საკლები
    :param simravle_b: set სიმრავლე სხვაბოის ოპერატორის ხელმარჯვენა
    ოპერანდა - მაკლები
    :return: set სიმრავლე, სხვაბოის ოპერაციის შედეგად მიღებული
"""
def difference(simravle_a,simravle_b):
    print(f"ჩვენ გვაქვს ორი სიმრავლე, რომელთა სხვაობა უნდა ვიპოვოთ!")
    set_difference = simravle_a.difference(simravle_b)
    if set_difference == set():
        print("მოცემული სიმრავლეები იდენტურია, ან *SECOND*  სიმრავლის ყველა ელემენტი *FIRST* სიმრავლეშიც შედის!")
    else:
        print(f"მეორე, *SECOND* სიმრავლეში, არ შედის პირველი, *FIRST* სიმრავლის შემდეგი ელემენტები: {set_difference}")
        return set_difference
# difference({1,2},{1,2}), difference({2,4,15,6,2,4,23,2,1,17,221},{1,2,4})



"""
4. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებული A და B სიმრავლის
სიმეტრიულ სხვაობას გამოითვლის და დააბრუნებს

:param simravle_a: set სიმრავლე, სხვაბოის ოპერატორის ხელმარცხენა
ოპერანდა - საკლები
:param simravle_b: set სიმრავლე სხვაბოის ოპერატორის ხელმარჯვენა
ოპერანდა - მაკლები
:return: set სიმრავლე, სიმეტრიული სხვაბოის ოპერაციის შედეგად მიღებული
"""
def symmetric_difference(simravle_a, simravle_b):
    print(f"ჩვენ გვაქვს ორი სიმრავლე, რომელთა სიმეტრიული სხვაობის გაგება გვინდა!")
    set_difference_s = simravle_a.symmetric_difference(simravle_b)
    if set_difference_s == set():
        print(f"სიმრავლეები იდენტურია, ან *FIRST* სიას არ გააჩნია ისეთი ელემენტები, რომელიც *SECOND*-ში არ არის!")
    else:
        print(f"პირველ, *FIRST* სიმრავლეში, არ შედის მეორე, *SECOND* სიმრავლის შემდეგი ელემენტები: {set_difference_s}")
        return set_difference_s


#symmetric_difference({1, 2}, {1, 2}), symmetric_difference({2,4,15,6,2,4,23,2,1,17,221},{1,2,4})

"""
5. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებულ set_a სიმრავლეში
დაამატებს მეორე არგუმენტად მიწოდებულ ელემენტ elem-ს

:param set_a: set სიმრავლე, რომელშიც უნდა დაამატო ელემენტი
:param elem: any რამე მონაცემთა ტიპი, რომლის სიმრავლეში შენახვა გამართულია
"""
def set_add(set_a, elem):
    print(f"ჩვენ გვაქვს სიმრავლე {set_a}, რომელში უდნა დავამატოთ ელემენტი {elem}")
    set_a.add(elem)
    print(f"დამატების შედეგი: {set_a}")
    return set_a
#print(set_add({1,2,5},1644))

"""
6. დაწერე ფუნქცია, რომელიც არგუმენტად მიწოდებულ set_a სიმრავლიდან
წაშლის მეორე არგუმენტად მიწოდებულ ელემენტ elem-ს:

რამდენიმე გზა არსებობს ამის შესასრულებლად.

ერთ-ერთია:
0. შეამოწმე, elem არსებობს თუ არა set_a სიმრავლეში:
    ა. თუ ის არსებობს, წაშალე
    ბ. თუ არა, არ წაშალო

კიდევ შეგიძლია სიმრავლის მონაცემთა ტიპზე გამართული ერთ-ერთი მეთოდი
(ფუნქცია) გამოიძახო, რომელიც თავისით აგვარებს თუ არგუმენტად მიწოდებული
ელემენტი სიმრავლეში არ არსებობს წაშლისას.


:param set_a: set სიმრავლე, რომლიდანაც უნდა წავშალოთ ელემენტი
:param elem: any რამე მონაცემთა ტიპი, რომლის სიმრავლეში შენახვა გამართულია
და რომელიც **შეიძლება** იყოს სიმრავლეში
"""
def set_remove(set_a, elem):
    if (elem in set_a) is True:
        print(f"ჩვენ გვაქვს სიმრავლე {set_a}, რომლიდან უნდა წავშალოთ ელემენტი {elem}")
        set_a.discard(elem)
        print(f"წაშლის შედეგი: {set_a}")
    else:
        print(f"*{elem}* არ შედის სიმრავლეში: {set_a}")
    # set_a.remove(elem)
    # return set_a

# print(set_remove({1,2,5},5)),print(set_remove(set_remove({1,2,5},5),5))
"""
7. დაწერე ფუნქცია, რომელიც შეამოწმებს პირველ არგუმენტად მიწოდებული
სიმრავლე, set_a, არის თუ არა მეორე არგუმენტად მიწოდებული სიმრავლის,
set_b-ს, **ქვესიმრავლე**:

- თუ არის, დააბრუნე True
- თუ არ არის, დააბრუნე False

:param set_a: set სიმრავლე; ვამოწმებთ ეს არის თუ არა მეორე სიმრავლის
ქვესიმრავლე
:param set_b: set სიმრავლე; მეორე სიმრავლე, რაც შეიძლება წინის ზესიმრავლე
იყოს
:return: bool ლოგიკური მონაცემთა ტიპი
"""
def set_subset(set_a, set_b):
    if set_a.issubset(set_b) is True:
        answer = True
        return answer
    else:
        answer = False
        return answer

# set_subset({1,2,3},{1,2,3,4,5,6,7,})
# set_subset({1,2,3},{1,2,4,5,6,7})
"""
8. დაწერე ფუნქცია, რომელიც შეამოწმებს პირველ არგუმენტად მიწოდებული
სიმრავლე, set_a, არის თუ არა მეორე არგუმენტად მიწოდებული სიმრავლის,
set_b-ს, **ზესიმრავლე**:

- თუ არის, დააბრუნე True
- თუ არ არის, დააბრუნე False

:param set_a: set სიმრავლე; ვამოწმებთ ეს არის თუ არა მეორე სიმრავლის
ზესიმრავლე
:param set_b: set სიმრავლე; მეორე სიმრავლე, რაც შეიძლება წინის ზესიმრავლე
იყოს
:return: bool ლოგიკური მონაცემთა ტიპი
"""
def set_superset(set_a, set_b):
    answer = set_a.issuperset(set_b)
    return answer
    # if set_a.issuperset(set_b) is True:
    #     print(babu)
    #     return True
    # else:
    #     return print(False)

# set_superset({2, 3, 'სშია', 6},{1, 2, 3, 4, 5, 'სშია', 'არ სშია',6})
# set_superset({1, 2, 3, 4, 5, 'სშია', 'არ სშია'},{2, 3, 'სშია', 5})
# print(set_superset({1,2,3},{1,2,3,4,5,6,7})), print(set_superset({1,2,3,4,5,6,7},{1,2,3}))

def main():
    """
    მთავარი ფუნქცია, სადაც უნდა მოათავსოთ ზემოთ გაწერილი დამხმარე ფუნქციების
    გამოძახება. დეტალურად წაიკითხეთ ფუნქციის ტანში, კომენტარების სახით
    მოცემული ინსტრუქციები.



    ბოლოს მოსალოდნელი შედეგი:

    A: {1, 2, 3, 4, 5, 'სშია', 'არ სშია'}
    B: {'სშია', 2, 3, 6}
    A U B: {1, 2, 3, 4, 5, 6, 'სშია', 'არ სშია'}
    A ∩ B: {1, 2, 3, 4, 5, 6, 'სშია', 'არ სშია'}")
    A - B: {1, 4, 5, 'არ სშია'}
    B - A: {6}
    A \ B: {1, 4, 5, 6, 'არ სშია'}
    B \ A: {1, 4, 5, 'არ სშია', 6}
    ვამატებთ 4-ს სიმრავლე {'სშია', 2, 3, 6}-ში
    შედეგი: { 2, 3, 4, 6, 'სშია' }

    ვაკლებთ 6-ს სიმრავლე { 2, 3, 4, 6, 'სშია' }-დან
    შედეგი: {2, 3, 4, 5, 'სშია'}

    ვამოწმებთ, არის თუ არა A, B-ს ქვესიმრავლე
    False

    ვამოწმებთ, არის თუ არა B, A-ს ქვესიმრავლე
    True

    ვამოწმებთ, არის თუ არა A, B-ს ზესიმრავლე
    True

    ვამოწმებთ, არის თუ არა B, A-ს ზესიმრავლე
    False
    """
    # 0. გამოიძახეთ მე-0 დაწერილი ფუნქცია 2-ჯერ, რომ შექმნათ სიმრავლეები
    # ELEMENTEBI_1-სა და ELEMENTEBI_2-ის სიებისაგან
    # თითო შექმნილი სიმრავლე ცალკე ცვლადში შეინახე
    set_1 = list_to_set(ELEMENTEBI_1)
    time.sleep(1)
    set_2 = list_to_set(ELEMENTEBI_2)
    time.sleep(1)
    # 1. თითო სიმრავლე გამოიტანე კონსოლში
    print(f"A: {set_1}")
    print(f"B: {set_2}")
    time.sleep(2)

    # 2. მე-1 ფუნქცია გამოიძახე, მიაწოდე ორივე სიმრავლე, გამოიყვანე უნისონი,
    # გასაგებად დაბეჭდე შედეგი
    union(set_1, set_2)
    time.sleep(1)


    # 3. მე-2 ფუნქცია გამოიძახე, მიაწოდე ორივე სიმრავლე, გამოიყვანე თანაკვეთა,
    # გასაგებად დაბეჭდე შედეგი
    intersection(set_1, set_2)
    time.sleep(2)

    # 4. მე-3 ფუნქცია გამოიძახე, მიაწოდე ორივე სიმრავლე, გამოიყვანე სხვაბოა,
    # გასაგებად დაბეჭდე შედეგი
    difference(set_1, set_2)
    time.sleep(1)


    # 5. მე-3 ფუნქცია გამოიძახე, მიაწოდე ორივე სიმრავლე, გამოიყვანე სხვაბოა,
    # ოღონდ, ახლა არგუემენტების თანმიმდევრობა შეატრიალე
    difference(set_2, set_1)
    time.sleep(1)


    # 6. მე-4 ფუნქცია გამოიძახე, მიაწოდე ორივე სიმრავლე, გამოიყვანე სიმტერიული
    # სხვაბოა, გასაგებად დაბეჭდე შედეგი
    symmetric_difference(set_1,set_2)
    time.sleep(2)


    # 7. მე-4 ფუნქცია გამოიძახე, მიაწოდე ორივე სიმრავლე, გამოიყვანე სიმტერიული
    # სხვაბოა, გასაგებად დაბეჭდე შედეგი, ოღონდ, ახლა არგუმენტების
    # თანმიმდევრობა შეცვალე
    symmetric_difference(set_2, set_1)
    time.sleep(2)

    # 8. მე-5 ფუნქცია გამოიძახე, არგუმენტად მიაწოდე სიმრავლე და
    # რამე ელემენტი:
    #   - ეს ელემენტი შეიზლება იყოს რამე მუდმივა
    #   - თუ გინდა, შეგიძლია მომხმარებელს სთხოვო რამე მონაცემის შეტანა
    # დაბეჭდე ახალი სიმრავლე
    set_add(set_2, 4)
    time.sleep(1)



    # 9. მე-6 ფუნქცია გამოიძახე, არგუმენტად მიაწოდე სიმრავლე და
    # რამე ელემენტი:
    #   - ეს ელემენტი შეიზლება იყოს რამე მუდმივა
    #   - თუ გინდა, შეგიძლია მომხმარებელს სთხოვო რამე მონაცემის შეტანა
    # დაბეჭდე ახალი სიმრავლე
    set_test = { 2, 3, 4, 6, 'სშია' }
    set_remove(set_test,6)
    time.sleep(1)

    # 10. მე-7 ფუნქცია გამოიძახე, არგუმენტებად მიაწოდე მე-0 ნაბიჯის
    # შედეგად მიღებული სიმრავლეები
    print(f"A არის B-ს ქვესიმრავლე: {set_subset(set_1,set_2)}")
    time.sleep(1)

    # 11. მე-7 ფუნქცია გამოიძახე, არგუმენტებად მიაწოდე მე-0 ნაბიჯის
    # შედეგად მიღებული სიმრავლეები, ოღონდ არგუმენტების თანმიმდევრობა
    # შეცვალე
    print(f"B არის A-ს ქვესიმრავლე: {set_subset(set_2,set_1)}")
    time.sleep(1)


    # 12. მე-8 ფუნქცია გამოიძახე, არგუმენტებად მიაწოდე მე-0 ნაბიჯის
    # შედეგად მიღებული სიმრავლეები
    print(f"A არის B-ს ზესიმრავლე: {set_superset(set_1,set_2)}")
    time.sleep(1)

    # 13. მე-8 ფუნქცია გამოიძახე, არგუმენტებად მიაწოდე მე-0 ნაბიჯის
    # შედეგად მიღებული სიმრავლეები, ოღონდ არგუმენტების თანმიმდევრობა
    # შეცვალე
    print(f"B არის A-ს ზესიმრავლე: {set_superset(set_2,set_1)}")
time.sleep(1)


# main()
